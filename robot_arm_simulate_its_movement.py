# -*- coding: utf-8 -*-
"""robot arm simulate its movement..ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1e8cbbTJqtaG0wPPEn7WTkun0g70bVwm7

# Forward Kinematics

Here’s the Python code to calculate the position of the end effector (x, y) based on the given joint angles (θ₁, θ₂, θ₃) and link lengths (L₁, L₂, L₃).
"""

import numpy as np

def forward_kinematics(theta1, theta2, theta3, L1, L2, L3):
    # Convert angles from degrees to radians
    theta1 = np.radians(theta1)
    theta2 = np.radians(theta2)
    theta3 = np.radians(theta3)

    # Calculate the position of the end effector
    x = L1 * np.cos(theta1) + L2 * np.cos(theta1 + theta2) + L3 * np.cos(theta1 + theta2 + theta3)
    y = L1 * np.sin(theta1) + L2 * np.sin(theta1 + theta2) + L3 * np.sin(theta1 + theta2 + theta3)

    return x, y

# Example usage:
theta1, theta2, theta3 = 30, 45, 60  # joint angles in degrees
L1, L2, L3 = 5, 5, 5  # link lengths

x, y = forward_kinematics(theta1, theta2, theta3, L1, L2, L3)
print(f"End Effector Position: x = {x:.2f}, y = {y:.2f}")

"""# Inverse Kinematics

Here’s the Python code to compute the joint angles (θ₁, θ₂, θ₃) required to place the end effector at a given position (x, y).
"""

import numpy as np

def inverse_kinematics(x, y, L1, L2, L3):
    # Calculate the position of the wrist (ignoring the third link)
    wrist_x = x - L3 * np.cos(np.arctan2(y, x))
    wrist_y = y - L3 * np.sin(np.arctan2(y, x))

    # Use the cosine rule to find the angles
    cos_theta2 = (wrist_x**2 + wrist_y**2 - L1**2 - L2**2) / (2 * L1 * L2)
    theta2 = np.arccos(np.clip(cos_theta2, -1.0, 1.0))  # Clipping to avoid numerical errors

    theta1 = np.arctan2(wrist_y, wrist_x) - np.arctan2(L2 * np.sin(theta2), L1 + L2 * np.cos(theta2))

    theta3 = np.arctan2(y, x) - theta1 - theta2

    # Convert angles from radians to degrees
    theta1 = np.degrees(theta1)
    theta2 = np.degrees(theta2)
    theta3 = np.degrees(theta3)

    return theta1, theta2, theta3

# Example usage:
x, y = 7, 5  # position of the end effector
L1, L2, L3 = 5, 5, 5  # link lengths

theta1, theta2, theta3 = inverse_kinematics(x, y, L1, L2, L3)
print(f"Joint Angles: θ1 = {theta1:.2f}°, θ2 = {theta2:.2f}°, θ3 = {theta3:.2f}°")

"""# Simulation and Visualization
python code to visualize the 3-link robot arm in 2D using Matplotlib.
"""

import numpy as np
import matplotlib.pyplot as plt

def plot_robot(theta1, theta2, theta3, L1, L2, L3):
    # Convert angles from degrees to radians
    theta1 = np.radians(theta1)
    theta2 = np.radians(theta2)
    theta3 = np.radians(theta3)

    # Calculate joint positions
    x0, y0 = 0, 0  # Base of the robot
    x1, y1 = L1 * np.cos(theta1), L1 * np.sin(theta1)
    x2, y2 = x1 + L2 * np.cos(theta1 + theta2), y1 + L2 * np.sin(theta1 + theta2)
    x3, y3 = x2 + L3 * np.cos(theta1 + theta2 + theta3), y2 + L3 * np.sin(theta1 + theta2 + theta3)

    # Plot the robot arm
    plt.figure()
    plt.plot([x0, x1, x2, x3], [y0, y1, y2, y3], 'o-', linewidth=4, markersize=8)
    plt.xlim(-sum([L1, L2, L3]), sum([L1, L2, L3]))
    plt.ylim(-sum([L1, L2, L3]), sum([L1, L2, L3]))
    plt.xlabel('X')
    plt.ylabel('Y')
    plt.title('3-Link Robot Arm')
    plt.grid(True)
    plt.show()

# Example usage:
theta1, theta2, theta3 = 30, 45, 60  # joint angles in degrees
L1, L2, L3 = 5, 5, 5  # link lengths

plot_robot(theta1, theta2, theta3, L1, L2, L3)

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

# Function to compute joint positions based on the angles and link lengths
def compute_positions(theta1, theta2, theta3, L1, L2, L3):
    theta1 = np.radians(theta1)
    theta2 = np.radians(theta2)
    theta3 = np.radians(theta3)

    x0, y0 = 0, 0  # Base of the robot
    x1, y1 = L1 * np.cos(theta1), L1 * np.sin(theta1)
    x2, y2 = x1 + L2 * np.cos(theta1 + theta2), y1 + L2 * np.sin(theta1 + theta2)
    x3, y3 = x2 + L3 * np.cos(theta1 + theta2 + theta3), y2 + L3 * np.sin(theta1 + theta2 + theta3)

    return (x0, y0), (x1, y1), (x2, y2), (x3, y3)

# Function to update the animation
def update(frame, theta1_vals, theta2_vals, theta3_vals, L1, L2, L3, line):
    theta1 = theta1_vals[frame]
    theta2 = theta2_vals[frame]
    theta3 = theta3_vals[frame]

    positions = compute_positions(theta1, theta2, theta3, L1, L2, L3)
    x_data = [pos[0] for pos in positions]
    y_data = [pos[1] for pos in positions]

    line.set_data(x_data, y_data)
    return line,

# Main function to plot and animate the robot arm
def animate_robot(theta1_vals, theta2_vals, theta3_vals, L1, L2, L3):
    fig, ax = plt.subplots()
    ax.set_xlim(-sum([L1, L2, L3]), sum([L1, L2, L3]))
    ax.set_ylim(-sum([L1, L2, L3]), sum([L1, L2, L3]))
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_title('Animated 3-Link Robot Arm')
    ax.grid(True)

    line, = ax.plot([], [], 'o-', linewidth=4, markersize=8)

    ani = animation.FuncAnimation(fig, update, frames=len(theta1_vals),
                                  fargs=(theta1_vals, theta2_vals, theta3_vals, L1, L2, L3, line),
                                  interval=200, blit=True, repeat=True)
    plt.show()

# Example usage with varying angles over time:
theta1_vals = np.linspace(0, 60, 100)  # From 0 to 60 degrees
theta2_vals = np.linspace(0, 45, 100)  # From 0 to 45 degrees
theta3_vals = np.linspace(0, 30, 100)  # From 0 to 30 degrees

L1, L2, L3 = 5, 5, 5  # Link lengths

animate_robot(theta1_vals, theta2_vals, theta3_vals, L1, L2, L3)

